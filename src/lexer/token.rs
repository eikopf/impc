//! The [`Token`] type and associated definitions.

use std::{fmt::Write, ops::Deref, str::FromStr};

use nom::{error::VerboseError, InputLength};

use super::{parse_tokens, LexError};

/// A token which owns its variables.
pub type OwnedToken<T> = Token<String, T>;
/// A token which references its variables.
pub type TokenRef<'src, T> = Token<&'src str, T>;

/// A token generated by parsing valid IMP source code.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Token<V, T> {
    /// A single semicolon (`;`).
    Semicolon,
    /// A single left parenthesis (`(`).
    LeftParen,
    /// A single right parenthesis (`)`).
    RightParen,
    /// The `skip` keyword.
    Skip,
    /// The assignment operator (`:=`).
    Assign,
    /// A single asterisk (`*`).
    Star,
    /// A single plus sign (`+`).
    Plus,
    /// A single minus sign (`-`).
    Minus,
    /// The `if` keyword.
    If,
    /// The `then` keyword.
    Then,
    /// The `else` keyword.
    Else,
    /// The `fi` keyword.
    Fi,
    /// The `while` keyword.
    While,
    /// The `do` keyword.
    Do,
    /// The `od` keyword.
    Od,
    /// The `true` keyword.
    True,
    /// The `false` keyword.
    False,
    /// A single equals sign (`=`).
    Equals,
    /// A single left angle bracket (`<`).
    LeftAngleBracket,
    /// A single right angle bracket (`>`).
    RightAngleBracket,
    /// The `not` keyword.
    Not,
    /// The `and` keyword,
    And,
    /// The `or` keyword,
    Or,
    /// A variable name.
    Var(V),
    /// An integer value.
    Int(T),
}

impl<V, T> InputLength for Token<V, T> {
    #[inline]
    fn input_len(&self) -> usize {
        1
    }
}

impl<T> From<Token<&str, T>> for Token<String, T> {
    fn from(value: Token<&str, T>) -> Self {
        match value {
            Token::Var(var) => Token::Var(var.to_string()),
            Token::Int(int) => Token::Int(int),
            Token::Semicolon => Token::Semicolon,
            Token::LeftParen => Token::LeftParen,
            Token::RightParen => Token::RightParen,
            Token::Skip => Token::Skip,
            Token::Assign => Token::Assign,
            Token::Star => Token::Star,
            Token::Plus => Token::Plus,
            Token::Minus => Token::Minus,
            Token::If => Token::If,
            Token::Then => Token::Then,
            Token::Else => Token::Else,
            Token::Fi => Token::Fi,
            Token::While => Token::While,
            Token::Do => Token::Do,
            Token::Od => Token::Od,
            Token::True => Token::True,
            Token::False => Token::False,
            Token::Equals => Token::Equals,
            Token::LeftAngleBracket => Token::LeftAngleBracket,
            Token::RightAngleBracket => Token::RightAngleBracket,
            Token::Not => Token::Not,
            Token::And => Token::And,
            Token::Or => Token::Or,
        }
    }
}

/// A thin wrapper around an owned [`Token`] slice.
#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Tokens<V, T> {
    /// The underlying [`Token`] buffer.
    tokens: Box<[Token<V, T>]>,
}

impl<V, T> std::fmt::Display for Tokens<V, T>
where
    V: std::fmt::Display,
    T: std::fmt::Display,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            self.tokens.iter().fold(String::new(), |mut buf, token| {
                let _ = writeln!(
                    buf,
                    "{}",
                    match token {
                        Token::Var(var) => format!("{var}"),
                        Token::Int(int) => format!("{int}"),
                        other => String::from(match other {
                            Token::Semicolon => "SEMICOLON",
                            Token::LeftParen => "LEFTPAREN",
                            Token::RightParen => "RIGHTPAREN",
                            Token::Skip => "SKIP",
                            Token::Assign => "ASSIGN",
                            Token::Star => "STAR",
                            Token::Plus => "PLUS",
                            Token::Minus => "MINUS",
                            Token::If => "IF",
                            Token::Then => "THEN",
                            Token::Else => "ELSE",
                            Token::Fi => "FI",
                            Token::While => "WHILE",
                            Token::Do => "DO",
                            Token::Od => "OD",
                            Token::True => "TRUE",
                            Token::False => "FALSE",
                            Token::Equals => "EQUALS",
                            Token::LeftAngleBracket => "LEFTANGLEBRACKET",
                            Token::RightAngleBracket => "RIGHTANGLEBRACKET",
                            Token::Not => "NOT",
                            Token::And => "AND",
                            Token::Or => "OR",
                            _ => unreachable!("var and int variants have already been caught"),
                        }),
                    }
                );

                buf
            })
        )
    }
}

impl<V, T> Deref for Tokens<V, T> {
    type Target = [Token<V, T>];

    fn deref(&self) -> &Self::Target {
        &self.tokens
    }
}

impl<'buf, 'src, T: Clone> From<&'buf [Token<&'src str, T>]> for Tokens<String, T> {
    fn from(value: &'buf [Token<&'src str, T>]) -> Self {
        Self {
            tokens: value
                .iter()
                .map(|token| match token {
                    Token::Var(var) => Token::Var(String::from(*var)),
                    other => other.clone().into(),
                })
                .collect(),
        }
    }
}

impl<'src, T: FromStr> TryFrom<&'src str> for Tokens<&'src str, T> {
    type Error = VerboseError<&'src str>;

    fn try_from(value: &'src str) -> Result<Self, Self::Error> {
        parse_tokens(value).map(|tokens| Self {
            tokens: tokens.into_boxed_slice(),
        })
    }
}

impl<T: FromStr> FromStr for Tokens<String, T> {
    type Err = LexError<String>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match parse_tokens::<T>(s) {
            Ok(tokens) => Ok(Self {
                tokens: tokens.into_iter().map(Into::into).collect::<Box<[_]>>(),
            }),
            Err(err) => Err(super::owned_lex_error(err)),
        }
    }
}

impl<V, T> Tokens<V, T> {
    /// Creates a new [`Tokens`] by cloning the given `tokens`.
    pub fn new(tokens: &[Token<V, T>]) -> Self
    where
        Token<V, T>: Clone,
    {
        Self {
            tokens: tokens.to_vec().into_boxed_slice(),
        }
    }

    /// Returns a reference to the underlying [`Token`] buffer as a slice.
    pub fn as_slice(&self) -> &[Token<V, T>] {
        self.tokens.as_ref()
    }
}
