//! The [`Token`] type and associated definitions.

use std::{ops::Deref, str::FromStr};

use nom::{error::VerboseError, InputLength};

use crate::int::ImpSize;

use super::{parse_tokens, LexError};

/// A token which owns its variables.
pub type OwnedToken<T> = Token<String, T>;
/// A token which references its variables.
pub type TokenRef<'src, T> = Token<&'src str, T>;

/// A token generated by parsing valid IMP source code.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Token<V, T = ImpSize> {
    /// A single semicolon (`;`).
    Semicolon,
    /// A single left parenthesis (`(`).
    LeftParen,
    /// A single right parenthesis (`)`).
    RightParen,
    /// The `skip` keyword.
    Skip,
    /// The assignment operator (`:=`).
    Assign,
    /// A single asterisk (`*`).
    Star,
    /// A single plus sign (`+`).
    Plus,
    /// A single minus sign (`-`).
    Minus,
    /// The `if` keyword.
    If,
    /// The `then` keyword.
    Then,
    /// The `else` keyword.
    Else,
    /// The `fi` keyword.
    Fi,
    /// The `while` keyword.
    While,
    /// The `do` keyword.
    Do,
    /// The `od` keyword.
    Od,
    /// The `true` keyword.
    True,
    /// The `false` keyword.
    False,
    /// A single equals sign (`=`).
    Equals,
    /// A single left angle bracket (`<`).
    LeftAngleBracket,
    /// A single right angle bracket (`>`).
    RightAngleBracket,
    /// The `not` keyword.
    Not,
    /// The `and` keyword,
    And,
    /// The `or` keyword,
    Or,
    /// A variable name.
    Var(V),
    /// An integer value.
    Int(T),
}

impl<V, T> InputLength for Token<V, T> {
    #[inline]
    fn input_len(&self) -> usize {
        1
    }
}

impl<T> From<Token<&str, T>> for Token<String, T> {
    fn from(value: Token<&str, T>) -> Self {
        match value {
            Token::Var(var) => Token::Var(var.to_string()),
            other => other.into(),
        }
    }
}

/// A thin wrapper around an owned [`Token`] slice.
#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Tokens<V, T = ImpSize> {
    /// The underlying [`Token`] buffer.
    tokens: Box<[Token<V, T>]>,
}

impl<V, T> Deref for Tokens<V, T> {
    type Target = [Token<V, T>];

    fn deref(&self) -> &Self::Target {
        &self.tokens
    }
}

impl<'src, T: FromStr> TryFrom<&'src str> for Tokens<&'src str, T> {
    type Error = VerboseError<&'src str>;

    fn try_from(value: &'src str) -> Result<Self, Self::Error> {
        parse_tokens(value).map(|tokens| Self {
            tokens: tokens.into_boxed_slice(),
        })
    }
}

impl<T: FromStr> FromStr for Tokens<String, T> {
    type Err = LexError<String>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match parse_tokens::<T>(s) {
            Ok(tokens) => Ok(Self {
                tokens: tokens.into_iter().map(Into::into).collect::<Box<[_]>>(),
            }),
            Err(err) => Err(super::owned_lex_error(err)),
        }
    }
}

impl<V, T> Tokens<V, T> {
    /// Creates a new [`Tokens`] by cloning the given `tokens`.
    pub fn new(tokens: &[Token<V, T>]) -> Self
    where
        Token<V, T>: Clone,
    {
        Self {
            tokens: tokens.to_vec().into_boxed_slice(),
        }
    }

    /// Returns a reference to the underlying [`Token`] buffer as a slice.
    pub fn as_slice(&self) -> &[Token<V, T>] {
        self.tokens.as_ref()
    }
}
