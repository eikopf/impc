//! The [`Token`] type and associated definitions.

use std::{
    ops::Deref,
    str::FromStr,
};

use nom::{error::VerboseError, InputLength};

use crate::int::ImpSize;

use super::parse_tokens;

/// A token which owns its variables.
pub type OwnedToken<T> = Token<String, T>;
/// A token which references its variables.
pub type TokenRef<'a, T> = Token<&'a str, T>;

/// A token generated by parsing valid IMP source code.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Token<V, T = ImpSize> {
    /// A single semicolon (`;`).
    Semicolon,
    /// A single left parenthesis (`(`).
    LeftParen,
    /// A single right parenthesis (`)`).
    RightParen,
    /// The `skip` keyword.
    Skip,
    /// The assignment operator (`:=`).
    Assign,
    /// A single asterisk (`*`).
    Star,
    /// A single plus sign (`+`).
    Plus,
    /// A single minus sign (`-`).
    Minus,
    /// The `if` keyword.
    If,
    /// The `then` keyword.
    Then,
    /// The `else` keyword.
    Else,
    /// The `fi` keyword.
    Fi,
    /// The `while` keyword.
    While,
    /// The `do` keyword.
    Do,
    /// The `od` keyword.
    Od,
    /// The `true` keyword.
    True,
    /// The `false` keyword.
    False,
    /// A single equals sign (`=`).
    Equals,
    /// A single left angle bracket (`<`).
    LeftAngleBracket,
    /// A single right angle bracket (`>`).
    RightAngleBracket,
    /// The `not` keyword.
    Not,
    /// The `and` keyword,
    And,
    /// The `or` keyword,
    Or,
    /// A variable name.
    Var(V),
    /// An integer value.
    Int(T),
}

impl<V, T> InputLength for Token<V, T> {
    #[inline]
    fn input_len(&self) -> usize {
        1
    }
}

/// A thin wrapper around an owned [`Token`] slice,
/// from which [`TokensRef`] structs can be cheaply
/// created and passed around.
#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Tokens<V, T = ImpSize> {
    /// The underlying [`Token`] buffer.
    tokens: Box<[Token<V, T>]>,
}

impl<V, T> Deref for Tokens<V, T> {
    type Target = [Token<V, T>];

    fn deref(&self) -> &Self::Target {
        &self.tokens
    }
}

impl<'src, T: FromStr> TryFrom<&'src str> for Tokens<&'src str, T> {
    type Error = VerboseError<&'src str>;

    fn try_from(value: &'src str) -> Result<Self, Self::Error> {
        parse_tokens(value).map(|tokens| Self {
            tokens: tokens.into_boxed_slice(),
        })
    }
}

impl<V, T> Tokens<V, T> {
    /// Creates a new [`Tokens`] by cloning the given `tokens`.
    pub fn new(tokens: &[Token<V, T>]) -> Self
    where
        V: Clone,
        T: Clone,
    {
        Self {
            tokens: tokens.to_vec().into_boxed_slice(),
        }
    }

    /// Returns a reference to the underlying [`Token`] buffer as a slice.
    pub fn as_slice(&self) -> &[Token<V, T>] {
        self.tokens.as_ref()
    }
}
